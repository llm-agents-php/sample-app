This is an example of Agent with Tools, Memory and Initial Prompts. It can be used as a template for creating new agents and tools.
Important: Always use gp4-0-mini as the base model for new agents.
//app/src/Agents/AgentsCaller
namespace App\Agents\AgentsCaller;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class AskAgentInput
{
    public function __construct(
        #[Field(title: 'Agent Name', description: 'The name of the agent to ask.')]
        public string $name,
        #[Field(title: 'Question', description: 'The question to ask the agent.')]
        public string $question,
        #[Field(title: 'Output Schema', description: 'The schema of the output.')]
        public string $outputSchema,
    ) {}
}
//app/src/Agents/AgentsCaller
namespace App\Agents\AgentsCaller;
use LLM\Agents\AgentExecutor\ExecutorInterface;
use LLM\Agents\LLM\Prompt\Chat\ToolCallResultMessage;
use LLM\Agents\LLM\Response\ToolCalledResponse;
use LLM\Agents\PromptGenerator\Context;
use LLM\Agents\Tool\PhpTool;
use LLM\Agents\Tool\ToolExecutor;
/**
 * @extends PhpTool<AskAgentInput>
 */
final class AskAgentTool extends PhpTool
{
    public const NAME = 'ask_agent';
    public function __construct(
        private readonly ExecutorInterface $executor,
        private readonly ToolExecutor $toolExecutor,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: AskAgentInput::class,
            description: 'Ask an agent with given name to execute a task.',
        );
    }
    public function execute(object $input): string|\Stringable
    {
        $prompt = \sprintf(
            <<<'PROMPT'
%s
Important rules:
- Think before responding to the user.
- Don not markup the content. Only JSON is allowed.
- Don't write anything except the answer using JSON schema.
- Answer in JSON using this schema:
%s
PROMPT
            ,
            $input->question,
            $input->outputSchema,
        );
        // TODO: make async
        while (true) {
            $execution = $this->executor->execute(agent: $input->name, prompt: $prompt, promptContext: new Context());
            $result = $execution->result;
            $prompt = $execution->prompt;
            if ($result instanceof ToolCalledResponse) {
                foreach ($result->tools as $tool) {
                    $functionResult = $this->toolExecutor->execute($tool->name, $tool->arguments);
                    $prompt = $prompt->withAddedMessage(
                        new ToolCallResultMessage(
                            id: $tool->id,
                            content: [$functionResult],
                        ),
                    );
                }
                continue;
            }
            break;
        }
        return \json_encode($result->content);
    }
}
//app/src/Agents/DynamicMemoryTool
namespace App\Agents\DynamicMemoryTool;
use LLM\Agents\Solution\SolutionMetadata;
use Ramsey\Uuid\UuidInterface;
use Traversable;
final class Memories implements \IteratorAggregate
{
    public function __construct(
        public readonly UuidInterface $uuid,
        /** @var array<SolutionMetadata> */
        public array $memories = [],
    ) {}
    public function addMemory(SolutionMetadata $metadata): void
    {
        $this->memories[] = $metadata;
    }
    public function getIterator(): Traversable
    {
        yield from $this->memories;
    }
}
//app/src/Agents/DynamicMemoryTool
namespace App\Agents\DynamicMemoryTool;
use App\Application\Entity\Uuid;
use LLM\Agents\Solution\MetadataType;
use LLM\Agents\Solution\SolutionMetadata;
use LLM\Agents\Tool\PhpTool;
final class DynamicMemoryTool extends PhpTool
{
    public const NAME = 'dynamic_memory';
    public function __construct(
        private readonly DynamicMemoryService $memoryService,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: DynamicMemoryInput::class,
            description: 'Use this tool to add or update a important memory about the user. This memory will be used in the future to provide a better experience.',
        );
    }
    public function execute(object $input): string
    {
        $metadata = new SolutionMetadata(
            type: MetadataType::Memory,
            key: 'user_memory',
            content: $input->preference,
        );
        $sessionUuid = Uuid::fromString($input->sessionId);
        $this->memoryService->addMemory($sessionUuid, $metadata);
        return 'Memory updated';
    }
}
//app/src/Agents/DynamicMemoryTool
namespace App\Agents\DynamicMemoryTool;
use App\Application\Entity\Uuid;
use LLM\Agents\Solution\SolutionMetadata;
use Psr\SimpleCache\CacheInterface;
use Spiral\Core\Attribute\Singleton;
#[Singleton]
final readonly class DynamicMemoryService
{
    public function __construct(
        private CacheInterface $cache,
    ) {}
    public function addMemory(Uuid $sessionUuid, SolutionMetadata $metadata): void
    {
        $memories = $this->getCurrentMemory($sessionUuid);
        $memories->addMemory($metadata);
        $this->cache->set($this->getKey($sessionUuid), $memories);
    }
    public function updateMemory(Uuid $sessionUuid, SolutionMetadata $metadata): void
    {
        $memories = $this->getCurrentMemory($sessionUuid);
        $memories->updateMemory($metadata);
        $this->cache->set($this->getKey($sessionUuid), $memories);
    }
    public function getCurrentMemory(Uuid $sessionUuid): Memories
    {
        return $this->cache->get($this->getKey($sessionUuid)) ?? new Memories(
            \Ramsey\Uuid\Uuid::uuid4(),
        );
    }
    private function getKey(Uuid $sessionUuid): string
    {
        return 'user_memory';
    }
}
//app/src/Agents/DynamicMemoryTool
namespace App\Agents\DynamicMemoryTool;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class DynamicMemoryInput
{
    public function __construct(
        #[Field(title: 'Session ID', description: 'The unique identifier for the current session')]
        public string $sessionId,
        #[Field(title: 'User preference', description: 'The user preference to add or update')]
        public string $preference,
    ) {}
}
//app/src/Agents/TaskSplitter
namespace App\Agents\TaskSplitter;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends PhpTool<ProjectDescriptionInput>
 */
final class GetProjectDescription extends PhpTool
{
    public const NAME = 'get_project_description';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: ProjectDescriptionInput::class,
            description: 'Get the description of a project from the project management system.',
        );
    }
    public function execute(object $input): string
    {
        return json_encode([
            'uuid' => $input->uuid,
            'title' => 'Оплата услуг клиентом',
            'description' => <<<'TEXT'
**As a customer, I want to be able to:**
- **Choose a subscription plan during registration:**
  - When creating an account on the service's website, I should be offered a choice of different subscription plans.
  - Each plan should include a clear description of the services provided and their costs.
- **Subscribe to a plan using a credit card:**
  - After selecting a plan, I need to provide my credit card details for payment.
  - There should be an option to save my card details for automatic monthly payments.
- **Receive monthly payment notifications:**
  - I expect to receive notifications via email or through my personal account about upcoming subscription charges.
  - The notification should arrive a few days before the charge, giving me enough time to ensure sufficient funds are available.
- **Access all necessary documents in my personal account:**
  - All financial documents, such as receipts and invoices, should be available for download at any time in my personal account.
- **Cancel the service if needed:**
  - I should be able to easily cancel my subscription through my personal account without needing to make additional calls or contact customer support.
- **Add a new card if the current one expires:**
  - If my credit card expires, I want to easily add a new card to the system through my personal account.
- **Continue using the service after cancellation until the end of the paid period:**
  - If I cancel my subscription, I expect to continue using the service until the end of the already paid period.
TEXT
            ,
        ]);
    }
}
//app/src/Agents/TaskSplitter
namespace App\Agents\TaskSplitter;
use LLM\Agents\Agent\AgentFactoryInterface;
use LLM\Agents\Agent\AgentInterface;
final class TaskSplitterAgentFactory implements AgentFactoryInterface
{
    public function create(): AgentInterface
    {
        return TaskSplitterAgent::create();
    }
}
//app/src/Agents/TaskSplitter
namespace App\Agents\TaskSplitter;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class ProjectDescriptionInput
{
    public function __construct(
        #[Field(title: 'Project ID', description: 'The ID of the project to get the description for.')]
        public string $uuid,
    ) {}
}
//app/src/Agents/TaskSplitter
namespace App\Agents\TaskSplitter;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class TaskCreateInput
{
    public function __construct(
        #[Field(title: 'Project UUID', description: 'The UUID of the project to which the task belongs.')]
        public string $projectUuid,
        #[Field(title: 'Task Name', description: 'The name of the task to be created.')]
        public string $name,
        #[Field(title: 'Task Description', description: 'The description of the task to be created.')]
        public string $description,
        #[Field(title: 'Parent Task ID', description: 'The ID of the parent task if this is a subtask. Empty string for top-level tasks. Multiple levels should be separated by a "/".')]
        public string $parentTaskUuid,
    ) {}
}
//app/src/Agents/TaskSplitter
namespace App\Agents\TaskSplitter;
use LLM\Agents\Agent\Agent;
use LLM\Agents\Agent\AgentAggregate;
use LLM\Agents\OpenAI\Client\OpenAIModel;
use LLM\Agents\OpenAI\Client\Option;
use LLM\Agents\Solution\MetadataType;
use LLM\Agents\Solution\Model;
use LLM\Agents\Solution\SolutionMetadata;
use LLM\Agents\Solution\ToolLink;
final class TaskSplitterAgent extends AgentAggregate
{
    public const NAME = 'task_splitter';
    public static function create(): self
    {
        $agent = new Agent(
            key: self::NAME,
            name: 'Task Splitter',
            description: 'An agent that splits project descriptions into structured task lists.',
            instruction: <<<'INSTRUCTION'
You are a task organization assistant.
Your primary goal is to analyze project descriptions and break them down into well-structured task lists with subtasks.
INSTRUCTION
            ,
        );
        $aggregate = new self($agent);
        $aggregate->addMetadata(
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'task_organization_tip',
                content: 'Always aim to create a logical hierarchy of tasks and subtasks. Main tasks should be broad objectives, while subtasks should be specific, actionable items.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'efficiency_tip',
                content: 'Try to keep the number of main tasks between 3 and 7 for better manageability. Break down complex tasks into subtasks when necessary.',
            ),
            // Prompts examples
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'split_task',
                content: 'Split the project description f47ac10b-58cc-4372-a567-0e02b2c3d479 into a list of tasks and subtasks.',
            ),
            new SolutionMetadata(
                type: MetadataType::Configuration,
                key: Option::MaxTokens->value,
                content: 3000,
            ),
        );
        $model = new Model(model: OpenAIModel::Gpt4oMini->value);
        $aggregate->addAssociation($model);
        $aggregate->addAssociation(new ToolLink(name: TaskCreateTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: GetProjectDescription::NAME));
        return $aggregate;
    }
}
//app/src/Agents/TaskSplitter
namespace App\Agents\TaskSplitter;
use App\Application\Entity\Uuid;
use LLM\Agents\Tool\PhpTool;
use Spiral\Boot\DirectoriesInterface;
use Spiral\Files\FilesInterface;
/**
 * @extends PhpTool<TaskCreateInput>
 */
final class TaskCreateTool extends PhpTool
{
    public const NAME = 'create_task';
    public function __construct(
        private readonly FilesInterface $files,
        private readonly DirectoriesInterface $dirs,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: TaskCreateInput::class,
            description: 'Create a task or subtask in the task management system.',
        );
    }
    public function execute(object $input): string
    {
        $uuid = (string) Uuid::generate();
        $dir = $this->dirs->get('runtime') . 'tasks/';
        if ($input->parentTaskUuid !== '') {
            $path = \sprintf('%s/%s/%s.json', $input->projectUuid, $input->parentTaskUuid, $uuid);
        } else {
            $path = \sprintf('%s/%s.json', $input->projectUuid, $uuid);
        }
        $fullPath = $dir . $path;
        $this->files->ensureDirectory(\dirname($fullPath));
        $this->files->touch($fullPath);
        $this->files->write(
            $fullPath,
            \sprintf(
                <<<'CONTENT'
uuid: %s
parent_uuid: %s
project_uuid: %s
---
## %s
%s
CONTENT,
                $uuid,
                $input->parentTaskUuid ?? '-',
                $input->projectUuid,
                $input->name,
                \trim($input->description),
            ),
        );
        return json_encode(['task_uuid' => $uuid]);
    }
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends PhpTool<ProfileInput>
 */
final class GetProfileTool extends PhpTool
{
    public const NAME = 'get_profile';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: ProfileInput::class,
            description: 'Get the customer\'s profile information.',
        );
    }
    public function execute(object $input): string
    {
        return \json_encode([
            'account_uuid' => $input->accountId,
            'first_name' => 'John',
            'last_name' => 'Doe',
            'age' => \rand(10, 100),
        ]);
    }
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use App\Agents\AgentsCaller\AskAgentTool;
use LLM\Agents\Agent\Agent;
use LLM\Agents\Agent\AgentAggregate;
use LLM\Agents\Agent\SiteStatusChecker\SiteStatusCheckerAgent;
use LLM\Agents\OpenAI\Client\OpenAIModel;
use LLM\Agents\Solution\AgentLink;
use LLM\Agents\Solution\MetadataType;
use LLM\Agents\Solution\Model;
use LLM\Agents\Solution\SolutionMetadata;
use LLM\Agents\Solution\ToolLink;
final class DeliveryAgent extends AgentAggregate
{
    public const NAME = 'order_assistant';
    public static function create(): self
    {
        $agent = new Agent(
            key: self::NAME,
            name: 'Order Assistant',
            description: 'Helps customers with order-related questions.',
            instruction: <<<'INSTRUCTION'
You are a helpful customer support assistant.
Use the supplied tools to assist the user.
INSTRUCTION
,
        );
        $aggregate = new self($agent);
        // Add some refiners to make the agent smarter
        $aggregate->addMetadata(
        // Memory
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'order_tip',
                content: 'First, retrieve the customer profile to provide personalized service.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'order_tip_server',
                content: 'Always check the server [google.com] status before providing any information.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'order_tip_repeat',
                content: 'Don\'t repeat the same information to the customer. If you have already provided the order number, don\'t repeat it. Provide only new information.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'order_tip_age',
                content: 'Tone of conversation is important, pay attention on age and fit the conversation to the age of the customer.',
            ),
            // Prompt
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'server_status',
                content: 'Check the server [google.com] status to ensure that the system is operational.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'what_is_order_number',
                content: 'What is my order number?',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'when_is_delivery',
                content: 'When will my order be delivered?',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'my_profile',
                content: 'Can you tell me more about my profile?',
            ),
        );
        // Add a model to the agent
        $model = new Model(model: OpenAIModel::Gpt4oMini->value);
        $aggregate->addAssociation($model);
        $aggregate->addAssociation(new ToolLink(name: GetDeliveryDateTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: GetOrderNumberTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: GetProfileTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: AskAgentTool::NAME));
        $aggregate->addAssociation(
            new AgentLink(
                name: SiteStatusCheckerAgent::NAME,
                outputSchema: StatusCheckOutput::class,
            ),
        );
        return $aggregate;
    }
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends PhpTool<OrderNumberInput>
 */
final class GetOrderNumberTool extends PhpTool
{
    public const NAME = 'get_order_number';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: OrderNumberInput::class,
            description: 'Get the order number for a customer.',
        );
    }
    public function execute(object $input): string
    {
        return \json_encode([
            'customer_id' => $input->customerId,
            'customer' => 'John Doe',
            'order_number' => 'abc-' . $input->customerId,
        ]);
    }
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use LLM\Agents\Agent\AgentFactoryInterface;
use LLM\Agents\Agent\AgentInterface;
final class DeliveryAgentFactory implements AgentFactoryInterface
{
    public function create(): AgentInterface
    {
        return DeliveryAgent::create();
    }
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class ProfileInput
{
    public function __construct(
        #[Field(title: 'Account ID', description: 'The customer\'s account ID.')]
        public string $accountId,
    ) {}
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class OrderNumberInput
{
    public function __construct(
        #[Field(title: 'Customer ID', description: 'The Customer ID')]
        public string $customerId,
    ) {}
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use Carbon\Carbon;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends PhpTool<DeliveryDateInput>
 */
final class GetDeliveryDateTool extends PhpTool
{
    public const NAME = 'get_delivery_date';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: DeliveryDateInput::class,
            description: 'Get the delivery date for a customer\'s order. Call this whenever you need to know the delivery date, for example when a customer asks \'Where is my package\'',
        );
    }
    public function execute(object $input): string
    {
        return \json_encode([
            'delivery_date' => Carbon::now()->addDays(\rand(1, 100))->toDateString(),
        ]);
    }
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class DeliveryDateInput
{
    public function __construct(
        #[Field(title: 'Order ID', description: 'The customer\'s order ID. Should be always uppercase!')]
        public string $orderId,
    ) {}
}
//app/src/Agents/Delivery
namespace App\Agents\Delivery;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class StatusCheckOutput
{
    public function __construct(
        #[Field(title: 'Status Code', description: 'The server status code.')]
        public string $code,
        #[Field(title: 'Response Time', description: 'The server response time in milliseconds.')]
        public string $responseTime,
        #[Field(title: 'Url', description: 'The server URL.')]
        public string $url,
    ) {}
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use LLM\Agents\Agent\Agent;
use LLM\Agents\Agent\AgentAggregate;
use LLM\Agents\OpenAI\Client\OpenAIModel;
use LLM\Agents\OpenAI\Client\Option;
use LLM\Agents\Solution\ContextSourceLink;
use LLM\Agents\Solution\MetadataType;
use LLM\Agents\Solution\Model;
use LLM\Agents\Solution\SolutionMetadata;
use LLM\Agents\Solution\ToolLink;
final class CodeReviewAgent extends AgentAggregate
{
    public static function create(): self
    {
        $agent = new Agent(
            key: 'code_review',
            name: 'Code Reviewer',
            description: 'Agent can list files in project with given id and then open each file and review the code',
            instruction: <<<'INSTRUCTION'
You are a code review assistant in Spiral Framework.
Use the provided tools to list project files, read their contents, and submit a code review for each file.
INSTRUCTION
            ,
        );
        $aggregate = new self($agent);
        $aggregate->addMetadata(
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'user_submitted_code_review',
                content: 'Always submit code reviews using proper tool.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'code_review_tip',
                content: 'Always submit constructive feedback and suggestions for improvement in your code reviews.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'customer_name',
                content: 'If you know the customer name say hello to them.',
            ),
            new SolutionMetadata(
                type: MetadataType::Configuration,
                key: Option::MaxTokens->value,
                content: 3000,
            ),
        );
        $model = new Model(model: OpenAIModel::Gpt4oMini->value);
        $aggregate->addAssociation($model);
        $aggregate->addAssociation(new ToolLink(name: ListProjectTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: ReadFileTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: ReviewTool::NAME));
        $aggregate->addAssociation(new ContextSourceLink(name: 'spiral-docs'));
        return $aggregate;
    }
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class ListProjectInput
{
    public function __construct(
        #[Field(title: 'Project Name', description: 'The name of the project to list files from.')]
        public string $name,
    ) {}
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class ReviewInput
{
    public function __construct(
        #[Field(title: 'Project Name', description: 'The name of the project.')]
        public string $name,
        #[Field(title: 'File Path', description: 'The path of the file being reviewed.')]
        public string $path,
        #[Field(title: 'Review Result', description: 'Code diff with suggested changes.')]
        public string $result,
    ) {}
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final class ReadFileInput
{
    public function __construct(
        #[Field(title: 'File Path', description: 'The path of the file to read.')]
        public string $path,
    ) {}
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends PhpTool<ListProjectInput>
 */
final class ListProjectTool extends PhpTool
{
    public const NAME = 'list_project';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: ListProjectInput::class,
            description: 'List all files in a project with the given project name.',
        );
    }
    public function execute(object $input): string
    {
        // Implementation to list project files
        return json_encode(['files' => ['file1.php', 'file2.php']]);
    }
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends  PhpTool<ReviewInput>
 */
final class ReviewTool extends PhpTool
{
    public const NAME = 'submit_review';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: ReviewInput::class,
            description: 'Submit a code review for a pull request. Call this whenever you need to submit a code review for a pull request.',
        );
    }
    public function execute(object $input): string
    {
        // Implementation to submit code review
        return json_encode(['status' => 'OK']);
    }
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use LLM\Agents\Agent\AgentFactoryInterface;
use LLM\Agents\Agent\AgentInterface;
final class CodeReviewAgentFactory implements AgentFactoryInterface
{
    public function create(): AgentInterface
    {
        return CodeReviewAgent::create();
    }
}
//app/src/Agents/CodeReviewer
namespace App\Agents\CodeReviewer;
use LLM\Agents\Tool\PhpTool;
/**
 * @extends PhpTool<ReadFileInput>
 */
final class ReadFileTool extends PhpTool
{
    public const NAME = 'read_file';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: ReadFileInput::class,
            description: 'Read the contents of a file at the given path.',
        );
    }
    public function execute(object $input): string
    {
        if ($input->path === 'file1.php') {
            return json_encode([
                'content' => <<<'PHP'
class ReviewTool extends \App\Domain\Tool\Tool
{
    public function __construct()
    {
        parent::__construct(
            name: 'review'
            inputSchema: ReviewInput::class,
            description: 'Submit a code review for a file at the given path.',
        );
    }
    public function getLanguage(): \App\Domain\Tool\ToolLanguage
    {
        return \App\Domain\Tool\ToolLanguage::PHP;
    }
    public function execute(object $input): string
    {
        // Implementation to submit code review
        return json_encode(['status' => 'success', 'message' => 'Code review submitted']);
    }
}
PHP,
            ]);
        }
        if ($input->path === 'file2.php') {
            return json_encode([
                'content' => <<<'PHP'
class ReadFileTool extends \App\Domain\Tool\Tool
{
    public function __construct()
    {
        parent::__construct(
            name: 'read_file',
            inputSchema: ReadFileInput::class,
            description: 'Read the contents of a file at the given path.',
        );
    }
    public function getLanguage(): \App\Domain\Tool\ToolLanguage
    {
        return \App\Domain\Tool\ToolLanguage:PHP;
    }
    public function execute(object $input): string
    {
        // Implementation to read file contents
        return json_encode(['content' => 'File contents here']);
    }
}
PHP,
            ]);
        }
        return 'File not found';
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
use LLM\Agents\Agent\Agent;
use LLM\Agents\Agent\AgentAggregate;
use LLM\Agents\Solution\MetadataType;
use LLM\Agents\Solution\Model;
use LLM\Agents\Solution\SolutionMetadata;
use LLM\Agents\Solution\ToolLink;
final class SiteStatusCheckerAgent extends AgentAggregate
{
    public const DEFAULT_MODEL = 'gpt-4o-mini';
    public const NAME = 'site_status_checker';
    public static function create(string $model = self::DEFAULT_MODEL): self
    {
        $agent = new Agent(
            key: self::NAME,
            name: 'Site Status Checker',
            description: 'This agent specializes in checking the online status of websites. It can verify if a given URL is accessible, retrieve basic information about the site, and provide insights on potential issues if a site is offline.',
            instruction: 'You are a website status checking assistant. Your primary goal is to help users determine if a website is online and provide relevant information about its status. Use the provided tools to check site availability, retrieve DNS information, and perform ping tests when necessary. Always aim to give clear, concise responses about a site\'s status and offer potential reasons or troubleshooting steps if a site appears to be offline.',
        );
        $aggregate = new self($agent);
        $aggregate->addMetadata(
            // Instructions
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'describe_decisions',
                content: 'Before calling any tools, describe the decisions you are making and why you are making them.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'check_availability_first',
                content: 'Always start by checking the site\'s availability before using other tools.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'don_not_repeat',
                content: 'Don\'t repeat yourself. If you have already provided something, don\'t repeat it unless necessary.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'offline_site_checks',
                content: 'If a site is offline, consider checking DNS information and performing a ping test to gather more data.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'explain_technical_terms',
                content: 'Provide clear explanations of technical terms and status codes for users who may not be familiar with them.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'suggest_troubleshooting',
                content: 'Suggest common troubleshooting steps if a site appears to be offline.',
            ),
            // Prompts examples
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'google',
                content: 'Check if google.com is online.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'offline_site',
                content: 'Can you check why buggregator.dev is offline?',
            ),
            new SolutionMetadata(
                type: MetadataType::Configuration,
                key: 'max_tokens',
                content: 3000,
            ),
        );
        $aggregate->addAssociation(
            new Model(model: $model)
        );
        $aggregate->addAssociation(new ToolLink(name: CheckSiteAvailabilityTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: GetDNSInfoTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: PerformPingTestTool::NAME));
        return $aggregate;
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
use LLM\Agents\Agent\AgentFactoryInterface;
use LLM\Agents\Agent\AgentInterface;
final readonly class SiteStatusCheckerAgentFactory implements AgentFactoryInterface
{
    public function create(string $model = SiteStatusCheckerAgent::DEFAULT_MODEL): AgentInterface
    {
        return SiteStatusCheckerAgent::create(
            model: $model,
        );
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
/**
 * @extends PhpTool<PerformPingTestInput>
 */
final class PerformPingTestTool extends PhpTool
{
    public const NAME = 'perform_ping_test';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: PerformPingTestInput::class,
            description: 'This tool performs a ping test to a specified host and returns the results, including response times and packet loss.',
        );
    }
    public function execute(object $input): string
    {
        // Implement the actual ping test here
        // This is a placeholder implementation
        $command = \sprintf('ping -c %d %s', 4, \escapeshellarg($input->host));
        \exec($command, $output, $returnVar);
        $packetLoss = 0;
        $avgRoundTripTime = 0;
        foreach ($output as $line) {
            if (str_contains($line, 'packet loss')) {
                \preg_match('/(\d+(?:\.\d+)?)%/', $line, $matches);
                $packetLoss = $matches[1] ?? 0;
            }
            if (str_contains($line, 'rtt min/avg/max')) {
                \preg_match('/= [\d.]+\/([\d.]+)\/[\d.]+/', $line, $matches);
                $avgRoundTripTime = $matches[1] ?? 0;
            }
        }
        return \json_encode([
            'packet_loss_percentage' => (float) $packetLoss,
            'avg_round_trip_time_ms' => (float) $avgRoundTripTime,
            'success' => $returnVar === 0,
        ]);
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class PerformPingTestInput
{
    public function __construct(
        #[Field(title: 'Host', description: 'The hostname or IP address to ping')]
        public string $host,
        #[Field(title: 'Steps', description: 'The number of times to ping the host')]
        public int $steps = 3
    ) {}
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class GetDNSInfoInput
{
    public function __construct(
        #[Field(title: 'Domain', description: 'The domain name to look up DNS information for')]
        public string $domain,
    ) {}
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
/**
 * @extends PhpTool<CheckSiteAvailabilityInput>
 */
final class CheckSiteAvailabilityTool extends PhpTool
{
    public const NAME = 'check_site_availability';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: CheckSiteAvailabilityInput::class,
            description: 'This tool checks if a given URL is accessible and returns its HTTP status code and response time.',
        );
    }
    public function execute(object $input): string
    {
        $ch = \curl_init($input->url);
        \curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_HEADER => true,
            CURLOPT_NOBODY => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_MAXREDIRS => 10,
            CURLOPT_TIMEOUT => 30,
        ]);
        $startTime = \microtime(true);
        $response = \curl_exec($ch);
        $endTime = \microtime(true);
        $statusCode = \curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $finalUrl = \curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
        $redirectCount = \curl_getinfo($ch, CURLINFO_REDIRECT_COUNT);
        $responseTime = \round(($endTime - $startTime) * 1000, 2);
        \curl_close($ch);
        $isOnline = $statusCode >= 200 && $statusCode < 400;
        return \json_encode([
            'status_code' => $statusCode,
            'response_time_ms' => $responseTime,
            'is_online' => $isOnline,
            'final_url' => $finalUrl,
            'redirect_count' => $redirectCount,
        ]);
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
use LLM\Agents\Tool\Tool;
use LLM\Agents\Tool\ToolLanguage;
abstract class PhpTool extends Tool
{
    public function getLanguage(): ToolLanguage
    {
        return ToolLanguage::PHP;
    }
}
//vendor/llm-agents/agent-site-status-checker/src/Integrations/Spiral
namespace LLM\Agents\Agent\SiteStatusChecker\Integrations\Spiral;
use LLM\Agents\Agent\AgentRegistryInterface;
use LLM\Agents\Agent\SiteStatusChecker\CheckSiteAvailabilityTool;
use LLM\Agents\Agent\SiteStatusChecker\GetDNSInfoTool;
use LLM\Agents\Agent\SiteStatusChecker\PerformPingTestTool;
use LLM\Agents\Agent\SiteStatusChecker\SiteStatusCheckerAgent;
use LLM\Agents\Agent\SiteStatusChecker\SiteStatusCheckerAgentFactory;
use LLM\Agents\Tool\ToolRegistryInterface;
use Spiral\Boot\Bootloader\Bootloader;
use Spiral\Boot\EnvironmentInterface;
final class SiteStatusCheckerBootloader extends Bootloader
{
    public function boot(
        AgentRegistryInterface $agents,
        ToolRegistryInterface $tools,
        SiteStatusCheckerAgentFactory $siteStatusCheckerAgentFactory,
        EnvironmentInterface $env,
    ): void {
        $agents->register(
            $siteStatusCheckerAgentFactory->create(
                $env->get('SITE_STATUS_CHECKER_MODEL', SiteStatusCheckerAgent::DEFAULT_MODEL),
            ),
        );
        $tools->register(
            new CheckSiteAvailabilityTool(),
            new GetDNSInfoTool(),
            new PerformPingTestTool(),
        );
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace App\Agents\SiteStatusChecker;
namespace LLM\Agents\Agent\SiteStatusChecker;
/**
 * @extends PhpTool<GetDNSInfoInput>
 */
final class GetDNSInfoTool extends PhpTool
{
    public const NAME = 'get_dns_info';
    public function __construct()
    {
        parent::__construct(
            name: self::NAME,
            inputSchema: GetDNSInfoInput::class,
            description: 'This tool retrieves DNS information for a given domain, including IP addresses and name servers.',
        );
    }
    public function execute(object $input): string
    {
        // Implement the actual DNS info retrieval here
        // This is a placeholder implementation
        $dnsRecords = \dns_get_record($input->domain, DNS_A + DNS_NS);
        $ipAddresses = \array_column(array_filter($dnsRecords, fn($record) => $record['type'] === 'A'), 'ip');
        $nameServers = \array_column(array_filter($dnsRecords, fn($record) => $record['type'] === 'NS'), 'target');
        return \json_encode([
            'ip_addresses' => $ipAddresses,
            'name_servers' => $nameServers,
        ]);
    }
}
//vendor/llm-agents/agent-site-status-checker/src
namespace LLM\Agents\Agent\SiteStatusChecker;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class CheckSiteAvailabilityInput
{
    public function __construct(
        #[Field(title: 'URL', description: 'The full URL of the website to check')]
        public string $url,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Agent\AgentFactoryInterface;
use LLM\Agents\Agent\AgentInterface;
final readonly class SymfonyConsoleAgentFactory implements AgentFactoryInterface
{
    public function __construct(
        private string $frameworkName,
    ) {}
    public function create(): AgentInterface
    {
        return SymfonyConsoleAgent::create(frameworkName: $this->frameworkName);
    }
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class GetCommandDetailsInput
{
    public function __construct(
        #[Field(title: 'Command', description: 'The name of the command to get details for')]
        public string $command,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Agent\AgentAggregate;
use LLM\Agents\Agent\Agent;
use LLM\Agents\Solution\Model;
use LLM\Agents\Solution\ToolLink;
use LLM\Agents\Solution\MetadataType;
use LLM\Agents\Solution\SolutionMetadata;
final class SymfonyConsoleAgent extends AgentAggregate
{
    public const NAME = 'symfony_console_agent';
    public static function create(
        string $frameworkName = 'Laravel',
    ): self {
        $agent = new Agent(
            key: self::NAME,
            name: 'Symfony Console Agent',
            description: 'This agent is designed to interact with console commands.',
            instruction: \sprintf(
                <<<'PROMPT'
You are an expert in %s framework.
You are a console command executor.
Your primary goal is to help users interact with console commands.
PROMPT,
                $frameworkName,
            ),
        );
        $aggregate = new self($agent);
        $aggregate->addMetadata(
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'console_agent',
                content: \sprintf(
                    <<<'PROMPT'
This agent is designed to interact with console commands for %s framework.',
PROMPT,
                    $frameworkName,
                ),
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'available_tools',
                content: <<<'PROMPT'
The Agent provides tools:
- get_commands_list,
- get_command_details,
- execute_command,
- read_file,
- write_file.
There is no other way to interact with the console commands.
PROMPT,
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'command_details',
                content: 'Always run `get_command_details` before the first command usage to understand what options and arguments are available.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'tools_usage',
                content: 'Before start always run `get_commands_list` to understand commands purpose.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'your_goal',
                content: 'A user provides a desired command to execute, and you should run it with the provided arguments and options.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'update_code',
                content: 'Some commands may require additional code to be added to the project.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'steps',
                content: <<<'PROMPT'
Think step by step. Run commands one by one without additional approves.
If you need to run multiple commands or tools, do it one by one.
PROMPT,
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'only_available_tools',
                content: 'Do not make up tools that are not available in the Agent. Use tool `execute_command` to run console commands.',
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'only_available_tools',
                content: <<<'PROMPT'
To create files always use console commands.
Do not use `write_file` tool to create files, only for writing content to existing files.
PROMPT,
            ),
            new SolutionMetadata(
                type: MetadataType::Memory,
                key: 'answer',
                content: 'Write only short summary answers. Do not provide long explanations and code snippets.',
            ),
            new SolutionMetadata(
                type: MetadataType::Configuration,
                key: 'max_tokens',
                content: 3_000,
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_user_model',
                content: 'Generate a Blog model with the following fields: title, content, and published_at.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_auth_middleware',
                content: 'Create a new middleware called AuthenticateAdmin to check if a user is an admin.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_order_event',
                content: 'Make an event class named OrderPlaced for when a new order is created.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_api_resource',
                content: 'Generate a new API resource for the Product model.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_custom_validation',
                content: 'Create a new validation rule called StrongPassword to ensure passwords meet specific criteria.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_email_notification',
                content: 'Make a new notification class for sending welcome emails to new users.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_database_seeder',
                content: 'Generate a seeder class to populate the categories table with initial data.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_custom_artisan_command',
                content: 'Create a new Artisan command called SendWeeklyNewsletter to automate newsletter distribution.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_api_controller',
                content: 'Make a new API controller for handling CRUD operations on the Post model.',
            ),
            new SolutionMetadata(
                type: MetadataType::Prompt,
                key: 'create_database_migration',
                content: 'Generate a migration to add a `status` column to the orders table.',
            ),
        );
        $aggregate->addAssociation(new Model(model: 'gpt-4o-mini'));
        $aggregate->addAssociation(new ToolLink(name: GetCommandsListTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: GetCommandDetailsTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: ExecuteCommandTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: ReadFileTool::NAME));
        $aggregate->addAssociation(new ToolLink(name: WriteFileTool::NAME));
        return $aggregate;
    }
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class Argument
{
    public function __construct(
        #[Field(title: 'Key', description: 'The key of the argument')]
        public string $key,
        #[Field(title: 'Value', description: 'The value of the argument')]
        public string $value,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class ExecuteCommandInput
{
    public function __construct(
        #[Field(title: 'Command', description: 'The name of the command to execute')]
        public string $command,
        /** @var array<Argument> */
        #[Field(title: 'Arguments', description: 'Command arguments')]
        public array $arguments,
        /** @var array<Option> */
        #[Field(title: 'Options', description: 'Command options')]
        public array $options,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Output\OutputInterface;
interface CommandManagerInterface
{
    public function getCommandHelp(string $command): string;
    /**
     * @return array<non-empty-string, Command>
     */
    public function getCommands(): array;
    /**
     * Run a console command by name.
     *
     * @return int The command exit code
     */
    public function call(
        string|\Stringable $command,
        array $parameters = [],
        ?OutputInterface $output = null,
    ): int;
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Tool\Tool;
use LLM\Agents\Tool\ToolLanguage;
use Symfony\Component\Console\Output\BufferedOutput;
final class ExecuteCommandTool extends Tool
{
    public const NAME = 'execute_command';
    public function __construct(
        private readonly CommandManagerInterface $application,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: ExecuteCommandInput::class,
            description: 'This tool executes a console command with the provided arguments and options.',
        );
    }
    public function getLanguage(): ToolLanguage
    {
        return ToolLanguage::PHP;
    }
    public function execute(object $input): string
    {
        $arguments = [];
        foreach ($input->arguments as $argument) {
            $arguments[$argument->key] = $argument->value;
        }
        foreach ($input->options as $option) {
            $value = $option->value;
            if ($option->value === '') {
                $value = true;
            }
            $arguments[$option->key][] = $value;
        }
        $output = new BufferedOutput();
        try {
            $exitCode = $this->application->call($input->command, $arguments, $output);
            $result = [
                'success' => $exitCode === 0,
                'output' => $output->fetch(),
                'exit_code' => $exitCode,
            ];
        } catch (\Exception $e) {
            $result = [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
        return \json_encode($result);
    }
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class WriteFileInput
{
    public function __construct(
        #[Field(title: 'Path', description: 'The path to the file to be written')]
        public string $path,
        #[Field(title: 'Content', description: 'The content to be written to the file')]
        public string $content,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Tool\Tool;
use LLM\Agents\Tool\ToolLanguage;
final class GetCommandsListTool extends Tool
{
    public const NAME = 'get_commands_list';
    public function __construct(
        private readonly CommandManagerInterface $application,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: GetCommandsListInput::class,
            description: 'Retrieves a list of available console commands with their descriptions.',
        );
    }
    public function getLanguage(): ToolLanguage
    {
        return ToolLanguage::PHP;
    }
    public function execute(object $input): string
    {
        $commands = $this->application->getCommands();
        $result = [];
        foreach ($commands as $name => $command) {
            $result[] = [
                'name' => $name,
                'description' => $command->getDescription(),
            ];
        }
        return \json_encode($result);
    }
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class ReadFileInput
{
    public function __construct(
        #[Field(title: 'Path', description: 'The path to the file to be read')]
        public string $path,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Tool\Tool;
use LLM\Agents\Tool\ToolLanguage;
final class GetCommandDetailsTool extends Tool
{
    public const NAME = 'get_command_details';
    public function __construct(
        private readonly CommandManagerInterface $application,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: GetCommandDetailsInput::class,
            description: 'Retrieves detailed information about a specific console command, including usage, arguments, and options.',
        );
    }
    public function getLanguage(): ToolLanguage
    {
        return ToolLanguage::PHP;
    }
    public function execute(object $input): string
    {
        $details = $this->application->getCommandHelp($input->command);
        return \json_encode([
            'help' => $details,
        ]);
    }
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class GetCommandsListInput
{
    public function __construct(
        #[Field(title: 'Namespace', description: 'Optional namespace to filter commands. Empty string to retrieve all commands')]
        public string $namespace,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Tool\Tool;
use LLM\Agents\Tool\ToolLanguage;
final class WriteFileTool extends Tool
{
    public const NAME = 'write_file';
    public function __construct(
        private readonly string $basePath,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: WriteFileInput::class,
            description: 'This tool writes content to a file at the given path.',
        );
    }
    public function getLanguage(): ToolLanguage
    {
        return ToolLanguage::PHP;
    }
    public function execute(object $input): string
    {
        $path = \rtrim($this->basePath, '/') . '/' . \ltrim($input->path, '/');
        // Strip doubled slashes in code namespaces
        $content = \preg_replace('/\\\\{2,}/', '\\', $input->content);
        $result = \file_put_contents($path, $content);
        if ($result === false) {
            return \json_encode(['error' => 'Unable to write to file']);
        }
        return \json_encode([
            'success' => true,
            'bytes_written' => $result,
            'path' => $input->path,
        ]);
    }
}
//vendor/llm-agents/agent-symfony-console/src/Integrations/Laravel
namespace LLM\Agents\Agent\SymfonyConsole\Integrations\Laravel;
use Illuminate\Contracts\Console\Kernel;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\ServiceProvider;
use LLM\Agents\Agent\AgentRegistryInterface;
use LLM\Agents\Agent\SymfonyConsole\CommandManagerInterface;
use LLM\Agents\Agent\SymfonyConsole\ExecuteCommandTool;
use LLM\Agents\Agent\SymfonyConsole\GetCommandDetailsTool;
use LLM\Agents\Agent\SymfonyConsole\GetCommandsListTool;
use LLM\Agents\Agent\SymfonyConsole\ReadFileTool;
use LLM\Agents\Agent\SymfonyConsole\SymfonyConsoleAgentFactory;
use LLM\Agents\Agent\SymfonyConsole\WriteFileTool;
use LLM\Agents\Tool\ToolRegistryInterface;
final class SymfonyConsoleServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->app->singleton(
            SymfonyConsoleAgentFactory::class,
            static fn() => new SymfonyConsoleAgentFactory('Laravel'),
        );
        $this->app->singleton(
            CommandManagerInterface::class,
            static fn(Application $app) => new ArtisanCommandManager($app->get(Kernel::class)),
        );
        $this->app->singleton(
            ExecuteCommandTool::class,
            static fn(Application $app) => new ExecuteCommandTool($app->get(CommandManagerInterface::class)),
        );
        $this->app->singleton(
            GetCommandDetailsTool::class,
            static fn(Application $app) => new GetCommandDetailsTool($app->get(CommandManagerInterface::class)),
        );
        $this->app->singleton(
            GetCommandsListTool::class,
            static fn(Application $app) => new GetCommandsListTool($app->get(CommandManagerInterface::class)),
        );
        $this->app->singleton(
            ReadFileTool::class,
            static fn(Application $app) => new ReadFileTool($app->basePath()),
        );
        $this->app->singleton(
            WriteFileTool::class,
            static fn(Application $app) => new WriteFileTool($app->basePath()),
        );
    }
    public function boot(
        AgentRegistryInterface $agents,
        ToolRegistryInterface $tools,
        SymfonyConsoleAgentFactory $agentFactory,
        CommandManagerInterface $commandManager,
        Application $app,
    ): void {
        $agents->register(
            $agentFactory->create(),
        );
        $tools->register(
            new ExecuteCommandTool($commandManager),
            new GetCommandDetailsTool($commandManager),
            new GetCommandsListTool($commandManager),
            new ReadFileTool($app->basePath()),
            new WriteFileTool($app->basePath()),
        );
    }
}
//vendor/llm-agents/agent-symfony-console/src/Integrations/Laravel
namespace LLM\Agents\Agent\SymfonyConsole\Integrations\Laravel;
use Illuminate\Contracts\Console\Kernel;
use LLM\Agents\Agent\SymfonyConsole\CommandManagerInterface;
use Symfony\Component\Console\Output\BufferedOutput;
use Symfony\Component\Console\Output\OutputInterface;
final readonly class ArtisanCommandManager implements CommandManagerInterface
{
    public function __construct(
        private Kernel $application,
        private array $enabledNamespaces = [
            'make:',
            'db:',
            'migrate',
            'route:list',
        ],
    ) {}
    public function getCommandHelp(string $command): string
    {
        $output = new BufferedOutput();
        $this->application->call($command, ['--help' => true], $output);
        return $output->fetch();
    }
    public function getCommands(): array
    {
        $commands = $this->application->all();
        $availableCommands = [];
        foreach ($this->enabledNamespaces as $namespace) {
            foreach ($commands as $name => $command) {
                if (\str_starts_with($name, $namespace)) {
                    $availableCommands[$name] = $command;
                }
            }
        }
        return $availableCommands;
    }
    public function call(\Stringable|string $command, array $parameters = [], ?OutputInterface $output = null): int
    {
        return $this->application->call($command, $parameters, $output);
    }
}
//vendor/llm-agents/agent-symfony-console/src/Integrations/Spiral
namespace LLM\Agents\Agent\SymfonyConsole\Integrations\Spiral;
use LLM\Agents\Agent\SymfonyConsole\CommandManagerInterface;
use Psr\Container\ContainerInterface;
use Spiral\Console\Console;
use Symfony\Component\Console\Output\BufferedOutput;
use Symfony\Component\Console\Output\OutputInterface;
final readonly class CommandManager implements CommandManagerInterface
{
    public function __construct(
        private ContainerInterface $app,
        private array $enabledNamespaces = [
            'create:',
            'cycle:',
            'migrate',
            'route:list',
        ],
    ) {}
    private function getConsole(): Console
    {
        return $this->app->get(Console::class);
    }
    public function getCommandHelp(string $command): string
    {
        $output = new BufferedOutput();
        $this->call($command, ['--help' => true], $output);
        return $output->fetch();
    }
    public function getCommands(): array
    {
        $commands = $this->getConsole()->getApplication()->all();
        $availableCommands = [];
        foreach ($this->enabledNamespaces as $namespace) {
            foreach ($commands as $name => $command) {
                if (\str_starts_with($name, $namespace)) {
                    $availableCommands[$name] = $command;
                }
            }
        }
        return $availableCommands;
    }
    public function call(\Stringable|string $command, array $parameters = [], ?OutputInterface $output = null): int
    {
        return $this->getConsole()->run((string) $command, $parameters, $output)->getCode();
    }
}
//vendor/llm-agents/agent-symfony-console/src/Integrations/Spiral
namespace LLM\Agents\Agent\SymfonyConsole\Integrations\Spiral;
use LLM\Agents\Agent\AgentRegistryInterface;
use LLM\Agents\Agent\SymfonyConsole\CommandManagerInterface;
use LLM\Agents\Agent\SymfonyConsole\ExecuteCommandTool;
use LLM\Agents\Agent\SymfonyConsole\GetCommandDetailsTool;
use LLM\Agents\Agent\SymfonyConsole\GetCommandsListTool;
use LLM\Agents\Agent\SymfonyConsole\ReadFileTool;
use LLM\Agents\Agent\SymfonyConsole\SymfonyConsoleAgentFactory;
use LLM\Agents\Agent\SymfonyConsole\WriteFileTool;
use LLM\Agents\Tool\ToolRegistryInterface;
use Spiral\Boot\Bootloader\Bootloader;
use Spiral\Boot\DirectoriesInterface;
final class SymfonyConsoleBootloader extends Bootloader
{
    public function defineSingletons(): array
    {
        return [
            SymfonyConsoleAgentFactory::class => static fn() => new SymfonyConsoleAgentFactory('Spiral'),
            CommandManagerInterface::class => CommandManager::class,
        ];
    }
    public function boot(
        AgentRegistryInterface $agents,
        ToolRegistryInterface $tools,
        SymfonyConsoleAgentFactory $agentFactory,
        CommandManagerInterface $commandManager,
        DirectoriesInterface $dirs,
    ): void {
        $agents->register(
            $agentFactory->create(),
        );
        $tools->register(
            new ExecuteCommandTool($commandManager),
            new GetCommandDetailsTool($commandManager),
            new GetCommandsListTool($commandManager),
            new ReadFileTool($dirs->get('root')),
            new WriteFileTool($dirs->get('root')),
        );
    }
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use Spiral\JsonSchemaGenerator\Attribute\Field;
final readonly class Option
{
    public function __construct(
        #[Field(title: 'Key', description: 'The key of the option')]
        public string $key,
        #[Field(title: 'Value', description: 'The value of the option')]
        public string $value,
    ) {}
}
//vendor/llm-agents/agent-symfony-console/src
namespace LLM\Agents\Agent\SymfonyConsole;
use LLM\Agents\Tool\Tool;
use LLM\Agents\Tool\ToolLanguage;
final class ReadFileTool extends Tool
{
    public const NAME = 'read_file';
    public function __construct(
        private readonly string $basePath,
    ) {
        parent::__construct(
            name: self::NAME,
            inputSchema: ReadFileInput::class,
            description: 'This tool reads the content of a file at the given path.',
        );
    }
    public function getLanguage(): ToolLanguage
    {
        return ToolLanguage::PHP;
    }
    public function execute(object $input): string
    {
        $path = \rtrim($this->basePath, '/') . '/' . \ltrim($input->path, '/');
        if (!file_exists($path)) {
            return \json_encode(['error' => 'File not found']);
        }
        $content = \file_get_contents($path);
        if ($content === false) {
            return \json_encode(['error' => 'Unable to read file']);
        }
        return \json_encode([
            'content' => $content,
            'path' => $input->path,
        ]);
    }
}
